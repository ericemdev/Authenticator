import "./chunk-NKHIPFFU.js";

// node_modules/jssha/dist/sha1.mjs
var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var r = "ARRAYBUFFER not supported by this environment";
var n = "UINT8ARRAY not supported by this environment";
function i(t2, r2, n2, i2) {
  let e2, s2, o2;
  const h2 = r2 || [0], u2 = (n2 = n2 || 0) >>> 3, f2 = -1 === i2 ? 3 : 0;
  for (e2 = 0; e2 < t2.length; e2 += 1)
    o2 = e2 + u2, s2 = o2 >>> 2, h2.length <= s2 && h2.push(0), h2[s2] |= t2[e2] << 8 * (f2 + i2 * (o2 % 4));
  return { value: h2, binLen: 8 * t2.length + n2 };
}
function e(e2, s2, o2) {
  switch (s2) {
    case "UTF8":
    case "UTF16BE":
    case "UTF16LE":
      break;
    default:
      throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
  }
  switch (e2) {
    case "HEX":
      return function(t2, r2, n2) {
        return function(t3, r3, n3, i2) {
          let e3, s3, o3, h2;
          if (0 != t3.length % 2)
            throw new Error("String of HEX type must be in byte increments");
          const u2 = r3 || [0], f2 = (n3 = n3 || 0) >>> 3, c2 = -1 === i2 ? 3 : 0;
          for (e3 = 0; e3 < t3.length; e3 += 2) {
            if (s3 = parseInt(t3.substr(e3, 2), 16), isNaN(s3))
              throw new Error("String of HEX type contains invalid characters");
            for (h2 = (e3 >>> 1) + f2, o3 = h2 >>> 2; u2.length <= o3; )
              u2.push(0);
            u2[o3] |= s3 << 8 * (c2 + i2 * (h2 % 4));
          }
          return { value: u2, binLen: 4 * t3.length + n3 };
        }(t2, r2, n2, o2);
      };
    case "TEXT":
      return function(t2, r2, n2) {
        return function(t3, r3, n3, i2, e3) {
          let s3, o3, h2, u2, f2, c2, a2, w2, E2 = 0;
          const l2 = n3 || [0], A2 = (i2 = i2 || 0) >>> 3;
          if ("UTF8" === r3)
            for (a2 = -1 === e3 ? 3 : 0, h2 = 0; h2 < t3.length; h2 += 1)
              for (s3 = t3.charCodeAt(h2), o3 = [], 128 > s3 ? o3.push(s3) : 2048 > s3 ? (o3.push(192 | s3 >>> 6), o3.push(128 | 63 & s3)) : 55296 > s3 || 57344 <= s3 ? o3.push(224 | s3 >>> 12, 128 | s3 >>> 6 & 63, 128 | 63 & s3) : (h2 += 1, s3 = 65536 + ((1023 & s3) << 10 | 1023 & t3.charCodeAt(h2)), o3.push(240 | s3 >>> 18, 128 | s3 >>> 12 & 63, 128 | s3 >>> 6 & 63, 128 | 63 & s3)), u2 = 0; u2 < o3.length; u2 += 1) {
                for (c2 = E2 + A2, f2 = c2 >>> 2; l2.length <= f2; )
                  l2.push(0);
                l2[f2] |= o3[u2] << 8 * (a2 + e3 * (c2 % 4)), E2 += 1;
              }
          else
            for (a2 = -1 === e3 ? 2 : 0, w2 = "UTF16LE" === r3 && 1 !== e3 || "UTF16LE" !== r3 && 1 === e3, h2 = 0; h2 < t3.length; h2 += 1) {
              for (s3 = t3.charCodeAt(h2), true === w2 && (u2 = 255 & s3, s3 = u2 << 8 | s3 >>> 8), c2 = E2 + A2, f2 = c2 >>> 2; l2.length <= f2; )
                l2.push(0);
              l2[f2] |= s3 << 8 * (a2 + e3 * (c2 % 4)), E2 += 2;
            }
          return { value: l2, binLen: 8 * E2 + i2 };
        }(t2, s2, r2, n2, o2);
      };
    case "B64":
      return function(r2, n2, i2) {
        return function(r3, n3, i3, e3) {
          let s3, o3, h2, u2, f2, c2, a2, w2 = 0;
          const E2 = n3 || [0], l2 = (i3 = i3 || 0) >>> 3, A2 = -1 === e3 ? 3 : 0, p2 = r3.indexOf("=");
          if (-1 === r3.search(/^[a-zA-Z0-9=+/]+$/))
            throw new Error("Invalid character in base-64 string");
          if (r3 = r3.replace(/=/g, ""), -1 !== p2 && p2 < r3.length)
            throw new Error("Invalid '=' found in base-64 string");
          for (o3 = 0; o3 < r3.length; o3 += 4) {
            for (f2 = r3.substr(o3, 4), u2 = 0, h2 = 0; h2 < f2.length; h2 += 1)
              s3 = t.indexOf(f2.charAt(h2)), u2 |= s3 << 18 - 6 * h2;
            for (h2 = 0; h2 < f2.length - 1; h2 += 1) {
              for (a2 = w2 + l2, c2 = a2 >>> 2; E2.length <= c2; )
                E2.push(0);
              E2[c2] |= (u2 >>> 16 - 8 * h2 & 255) << 8 * (A2 + e3 * (a2 % 4)), w2 += 1;
            }
          }
          return { value: E2, binLen: 8 * w2 + i3 };
        }(r2, n2, i2, o2);
      };
    case "BYTES":
      return function(t2, r2, n2) {
        return function(t3, r3, n3, i2) {
          let e3, s3, o3, h2;
          const u2 = r3 || [0], f2 = (n3 = n3 || 0) >>> 3, c2 = -1 === i2 ? 3 : 0;
          for (s3 = 0; s3 < t3.length; s3 += 1)
            e3 = t3.charCodeAt(s3), h2 = s3 + f2, o3 = h2 >>> 2, u2.length <= o3 && u2.push(0), u2[o3] |= e3 << 8 * (c2 + i2 * (h2 % 4));
          return { value: u2, binLen: 8 * t3.length + n3 };
        }(t2, r2, n2, o2);
      };
    case "ARRAYBUFFER":
      try {
        new ArrayBuffer(0);
      } catch (t2) {
        throw new Error(r);
      }
      return function(t2, r2, n2) {
        return function(t3, r3, n3, e3) {
          return i(new Uint8Array(t3), r3, n3, e3);
        }(t2, r2, n2, o2);
      };
    case "UINT8ARRAY":
      try {
        new Uint8Array(0);
      } catch (t2) {
        throw new Error(n);
      }
      return function(t2, r2, n2) {
        return i(t2, r2, n2, o2);
      };
    default:
      throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
  }
}
function s(i2, e2, s2, o2) {
  switch (i2) {
    case "HEX":
      return function(t2) {
        return function(t3, r2, n2, i3) {
          const e3 = "0123456789abcdef";
          let s3, o3, h2 = "";
          const u2 = r2 / 8, f2 = -1 === n2 ? 3 : 0;
          for (s3 = 0; s3 < u2; s3 += 1)
            o3 = t3[s3 >>> 2] >>> 8 * (f2 + n2 * (s3 % 4)), h2 += e3.charAt(o3 >>> 4 & 15) + e3.charAt(15 & o3);
          return i3.outputUpper ? h2.toUpperCase() : h2;
        }(t2, e2, s2, o2);
      };
    case "B64":
      return function(r2) {
        return function(r3, n2, i3, e3) {
          let s3, o3, h2, u2, f2, c2 = "";
          const a2 = n2 / 8, w2 = -1 === i3 ? 3 : 0;
          for (s3 = 0; s3 < a2; s3 += 3)
            for (u2 = s3 + 1 < a2 ? r3[s3 + 1 >>> 2] : 0, f2 = s3 + 2 < a2 ? r3[s3 + 2 >>> 2] : 0, h2 = (r3[s3 >>> 2] >>> 8 * (w2 + i3 * (s3 % 4)) & 255) << 16 | (u2 >>> 8 * (w2 + i3 * ((s3 + 1) % 4)) & 255) << 8 | f2 >>> 8 * (w2 + i3 * ((s3 + 2) % 4)) & 255, o3 = 0; o3 < 4; o3 += 1)
              c2 += 8 * s3 + 6 * o3 <= n2 ? t.charAt(h2 >>> 6 * (3 - o3) & 63) : e3.b64Pad;
          return c2;
        }(r2, e2, s2, o2);
      };
    case "BYTES":
      return function(t2) {
        return function(t3, r2, n2) {
          let i3, e3, s3 = "";
          const o3 = r2 / 8, h2 = -1 === n2 ? 3 : 0;
          for (i3 = 0; i3 < o3; i3 += 1)
            e3 = t3[i3 >>> 2] >>> 8 * (h2 + n2 * (i3 % 4)) & 255, s3 += String.fromCharCode(e3);
          return s3;
        }(t2, e2, s2);
      };
    case "ARRAYBUFFER":
      try {
        new ArrayBuffer(0);
      } catch (t2) {
        throw new Error(r);
      }
      return function(t2) {
        return function(t3, r2, n2) {
          let i3;
          const e3 = r2 / 8, s3 = new ArrayBuffer(e3), o3 = new Uint8Array(s3), h2 = -1 === n2 ? 3 : 0;
          for (i3 = 0; i3 < e3; i3 += 1)
            o3[i3] = t3[i3 >>> 2] >>> 8 * (h2 + n2 * (i3 % 4)) & 255;
          return s3;
        }(t2, e2, s2);
      };
    case "UINT8ARRAY":
      try {
        new Uint8Array(0);
      } catch (t2) {
        throw new Error(n);
      }
      return function(t2) {
        return function(t3, r2, n2) {
          let i3;
          const e3 = r2 / 8, s3 = -1 === n2 ? 3 : 0, o3 = new Uint8Array(e3);
          for (i3 = 0; i3 < e3; i3 += 1)
            o3[i3] = t3[i3 >>> 2] >>> 8 * (s3 + n2 * (i3 % 4)) & 255;
          return o3;
        }(t2, e2, s2);
      };
    default:
      throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
  }
}
function o(t2) {
  const r2 = { outputUpper: false, b64Pad: "=", outputLen: -1 }, n2 = t2 || {}, i2 = "Output length must be a multiple of 8";
  if (r2.outputUpper = n2.outputUpper || false, n2.b64Pad && (r2.b64Pad = n2.b64Pad), n2.outputLen) {
    if (n2.outputLen % 8 != 0)
      throw new Error(i2);
    r2.outputLen = n2.outputLen;
  } else if (n2.shakeLen) {
    if (n2.shakeLen % 8 != 0)
      throw new Error(i2);
    r2.outputLen = n2.shakeLen;
  }
  if ("boolean" != typeof r2.outputUpper)
    throw new Error("Invalid outputUpper formatting option");
  if ("string" != typeof r2.b64Pad)
    throw new Error("Invalid b64Pad formatting option");
  return r2;
}
var h = class {
  constructor(t2, r2, n2) {
    const i2 = n2 || {};
    if (this.t = r2, this.i = i2.encoding || "UTF8", this.numRounds = i2.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds)
      throw new Error("numRounds must a integer >= 1");
    this.o = t2, this.h = [], this.u = 0, this.l = false, this.A = 0, this.p = false, this.U = [], this.R = [];
  }
  update(t2) {
    let r2, n2 = 0;
    const i2 = this.T >>> 5, e2 = this.F(t2, this.h, this.u), s2 = e2.binLen, o2 = e2.value, h2 = s2 >>> 5;
    for (r2 = 0; r2 < h2; r2 += i2)
      n2 + this.T <= s2 && (this.m = this.g(o2.slice(r2, r2 + i2), this.m), n2 += this.T);
    return this.A += n2, this.h = o2.slice(n2 >>> 5), this.u = s2 % this.T, this.l = true, this;
  }
  getHash(t2, r2) {
    let n2, i2, e2 = this.B;
    const h2 = o(r2);
    if (this.v) {
      if (-1 === h2.outputLen)
        throw new Error("Output length must be specified in options");
      e2 = h2.outputLen;
    }
    const u2 = s(t2, e2, this.H, h2);
    if (this.p && this.C)
      return u2(this.C(h2));
    for (i2 = this.Y(this.h.slice(), this.u, this.A, this.I(this.m), e2), n2 = 1; n2 < this.numRounds; n2 += 1)
      this.v && e2 % 32 != 0 && (i2[i2.length - 1] &= 16777215 >>> 24 - e2 % 32), i2 = this.Y(i2, e2, 0, this.L(this.o), e2);
    return u2(i2);
  }
  setHMACKey(t2, r2, n2) {
    if (!this.M)
      throw new Error("Variant does not support HMAC");
    if (this.l)
      throw new Error("Cannot set MAC key after calling update");
    const i2 = e(r2, (n2 || {}).encoding || "UTF8", this.H);
    this.N(i2(t2));
  }
  N(t2) {
    const r2 = this.T >>> 3, n2 = r2 / 4 - 1;
    let i2;
    if (1 !== this.numRounds)
      throw new Error("Cannot set numRounds with MAC");
    if (this.p)
      throw new Error("MAC key already set");
    for (r2 < t2.binLen / 8 && (t2.value = this.Y(t2.value, t2.binLen, 0, this.L(this.o), this.B)); t2.value.length <= n2; )
      t2.value.push(0);
    for (i2 = 0; i2 <= n2; i2 += 1)
      this.U[i2] = 909522486 ^ t2.value[i2], this.R[i2] = 1549556828 ^ t2.value[i2];
    this.m = this.g(this.U, this.m), this.A = this.T, this.p = true;
  }
  getHMAC(t2, r2) {
    const n2 = o(r2);
    return s(t2, this.B, this.H, n2)(this.S());
  }
  S() {
    let t2;
    if (!this.p)
      throw new Error("Cannot call getHMAC without first setting MAC key");
    const r2 = this.Y(this.h.slice(), this.u, this.A, this.I(this.m), this.B);
    return t2 = this.g(this.R, this.L(this.o)), t2 = this.Y(r2, this.B, this.T, t2, this.B), t2;
  }
};
function u(t2, r2) {
  return t2 << r2 | t2 >>> 32 - r2;
}
function f(t2, r2, n2) {
  return t2 ^ r2 ^ n2;
}
function c(t2, r2, n2) {
  return t2 & r2 ^ t2 & n2 ^ r2 & n2;
}
function a(t2, r2) {
  const n2 = (65535 & t2) + (65535 & r2);
  return (65535 & (t2 >>> 16) + (r2 >>> 16) + (n2 >>> 16)) << 16 | 65535 & n2;
}
function w(t2, r2, n2, i2, e2) {
  const s2 = (65535 & t2) + (65535 & r2) + (65535 & n2) + (65535 & i2) + (65535 & e2);
  return (65535 & (t2 >>> 16) + (r2 >>> 16) + (n2 >>> 16) + (i2 >>> 16) + (e2 >>> 16) + (s2 >>> 16)) << 16 | 65535 & s2;
}
function E(t2) {
  return [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
}
function l(t2, r2) {
  let n2, i2, e2, s2, o2, h2, E2;
  const l2 = [];
  for (n2 = r2[0], i2 = r2[1], e2 = r2[2], s2 = r2[3], o2 = r2[4], E2 = 0; E2 < 80; E2 += 1)
    l2[E2] = E2 < 16 ? t2[E2] : u(l2[E2 - 3] ^ l2[E2 - 8] ^ l2[E2 - 14] ^ l2[E2 - 16], 1), h2 = E2 < 20 ? w(u(n2, 5), (A2 = i2) & e2 ^ ~A2 & s2, o2, 1518500249, l2[E2]) : E2 < 40 ? w(u(n2, 5), f(i2, e2, s2), o2, 1859775393, l2[E2]) : E2 < 60 ? w(u(n2, 5), c(i2, e2, s2), o2, 2400959708, l2[E2]) : w(u(n2, 5), f(i2, e2, s2), o2, 3395469782, l2[E2]), o2 = s2, s2 = e2, e2 = u(i2, 30), i2 = n2, n2 = h2;
  var A2;
  return r2[0] = a(n2, r2[0]), r2[1] = a(i2, r2[1]), r2[2] = a(e2, r2[2]), r2[3] = a(s2, r2[3]), r2[4] = a(o2, r2[4]), r2;
}
function A(t2, r2, n2, i2) {
  let e2;
  const s2 = 15 + (r2 + 65 >>> 9 << 4), o2 = r2 + n2;
  for (; t2.length <= s2; )
    t2.push(0);
  for (t2[r2 >>> 5] |= 128 << 24 - r2 % 32, t2[s2] = 4294967295 & o2, t2[s2 - 1] = o2 / 4294967296 | 0, e2 = 0; e2 < t2.length; e2 += 16)
    i2 = l(t2.slice(e2, e2 + 16), i2);
  return i2;
}
var p = class extends h {
  constructor(t2, r2, n2) {
    if ("SHA-1" !== t2)
      throw new Error("Chosen SHA variant is not supported");
    super(t2, r2, n2);
    const i2 = n2 || {};
    this.M = true, this.C = this.S, this.H = -1, this.F = e(this.t, this.i, this.H), this.g = l, this.I = function(t3) {
      return t3.slice();
    }, this.L = E, this.Y = A, this.m = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.T = 512, this.B = 160, this.v = false, i2.hmacKey && this.N(function(t3, r3, n3, i3) {
      const s2 = t3 + " must include a value and format";
      if (!r3) {
        if (!i3)
          throw new Error(s2);
        return i3;
      }
      if (void 0 === r3.value || !r3.format)
        throw new Error(s2);
      return e(r3.format, r3.encoding || "UTF8", n3)(r3.value);
    }("hmacKey", i2.hmacKey, this.H));
  }
};
export {
  p as default
};
//# sourceMappingURL=jssha_dist_sha1.js.map
